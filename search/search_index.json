{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Autonomous UAV Implementation and Simulation for Drone Development This documentation describes the design, implementation and simulation of an open-source companion computer autonomy stack for PX4-based unmanned aerial vehicles (UAVs). The project focuses on companion-side software architecture, safety supervision, and reproducible development workflows rather than flight-controller firmware or vehicle-specific hardware. Motivation Modern autonomous UAV systems rely on a companion computer to perform perception, planning, and mission logic while delegating low-level controls like drone movement and stabilization to a flight controller like PX4. While PX4 provides documentation for Offboard control and communication interfaces, guidance on how to build companion-side autonomy is limited. Most publically available resources focus on: Basic ROS2 setup and message passing. Minimal examples of Offboard setpoint publishing. In practice, production-grade systems require significantly more structure: supervision, fault handling, deterministic control, and clear seperation between safety, control, and mission logic. While these patterns are well established in ground robotics in frameworks such as Nav2, there are not many established frameworks for single drone autonomy. Many mature companion-computer autonomy stacks are proprietary, domain-specific, or tightly coupled to internal company infrastructure, limiting their usefulness as a learning resource or reusable foundations for research and development. This project is motivated by the need for: A clear, open reference architecture for UAV companion computers. Practical workflows for development, testing, and simulation. A framework that can be extended to different levels of autonomy, missions, and research use-cases without rewriting core functionality. Scope The scope of this documentation is strictly limited to the companion computer software layer and its interaction with PX4 through Offboard control interfaces. It defines the design of the architecture itself as well as development workflows and how to use the provided implementation for your use-case. Documentation was written and tested with a Windows 11 + WSL2 environment. Although an example implementation of these concepts is provided, you could implement the architecture on your own. Description The UAV Lease-Gated Autonomy Stack is an open-source reference architecture and companion computer software framework for building safe, modular, and reproducible autonomous single-drone systems on top of PX4 and ROS2. Unlike basic Offboard examples that focus only on setpoint publishing or simple ROS2 message passing, this project delivers an autonomy stack with production in mind. The architecture takes inspiriation from existing ground-robotics patterns but adapts to the constraints of aerial vehicles. Autonomy is always explicity leased and is never implicitly assumed. Software Stack The stack integrates simulation, middleware, and layed autonomy logic for both development and eventual hardware deployment. Cosys-AirSim serves as the primary simulation environment (although Gazebo can work just as well for your implementation), providing high-fidelity rendering, physics, and sensor simulation, allowing for photo realistic testing and iteration without physical hardware. The companion computer communicates bidirectionally with the PX4 flight controller via uXRCE-DDS (the ROS2 bridge for PX4's uORB topics). This allows the autonomy stack to subscribe to vehicle state/telemetry and publish Offboard commands. Cosys-AirSim includes a ROS2 wrapper that bridges simulation sensor data into standard ROS2 topics, making it easy to feed behavior nodes. The autonomy logic itself is structued in three decoupled layers (read more in Architecture section). Supervisor Layer: continuous monitors system health, PX4 failsafe flags, node liveliness, resource usage, and environmental constraints. It leases autonomy to the control layer only when strict safety preconditions are met. Control Layer: enforced by the lease gate, validates and filters all outgoing commands, maintains communication with the PX4 flight controller, and falls back to safe hold setpoints when the lease is revoked. Decision Layer: generates high-level intent via composable behavior trees. It has no direct actuation authority as all outputs pass through validation and gating. Table of Contents","title":"Home"},{"location":"#autonomous-uav-implementation-and-simulation-for-drone-development","text":"This documentation describes the design, implementation and simulation of an open-source companion computer autonomy stack for PX4-based unmanned aerial vehicles (UAVs). The project focuses on companion-side software architecture, safety supervision, and reproducible development workflows rather than flight-controller firmware or vehicle-specific hardware.","title":"Autonomous UAV Implementation and Simulation for Drone Development"},{"location":"#motivation","text":"Modern autonomous UAV systems rely on a companion computer to perform perception, planning, and mission logic while delegating low-level controls like drone movement and stabilization to a flight controller like PX4. While PX4 provides documentation for Offboard control and communication interfaces, guidance on how to build companion-side autonomy is limited. Most publically available resources focus on: Basic ROS2 setup and message passing. Minimal examples of Offboard setpoint publishing. In practice, production-grade systems require significantly more structure: supervision, fault handling, deterministic control, and clear seperation between safety, control, and mission logic. While these patterns are well established in ground robotics in frameworks such as Nav2, there are not many established frameworks for single drone autonomy. Many mature companion-computer autonomy stacks are proprietary, domain-specific, or tightly coupled to internal company infrastructure, limiting their usefulness as a learning resource or reusable foundations for research and development. This project is motivated by the need for: A clear, open reference architecture for UAV companion computers. Practical workflows for development, testing, and simulation. A framework that can be extended to different levels of autonomy, missions, and research use-cases without rewriting core functionality.","title":"Motivation"},{"location":"#scope","text":"The scope of this documentation is strictly limited to the companion computer software layer and its interaction with PX4 through Offboard control interfaces. It defines the design of the architecture itself as well as development workflows and how to use the provided implementation for your use-case. Documentation was written and tested with a Windows 11 + WSL2 environment. Although an example implementation of these concepts is provided, you could implement the architecture on your own.","title":"Scope"},{"location":"#description","text":"The UAV Lease-Gated Autonomy Stack is an open-source reference architecture and companion computer software framework for building safe, modular, and reproducible autonomous single-drone systems on top of PX4 and ROS2. Unlike basic Offboard examples that focus only on setpoint publishing or simple ROS2 message passing, this project delivers an autonomy stack with production in mind. The architecture takes inspiriation from existing ground-robotics patterns but adapts to the constraints of aerial vehicles. Autonomy is always explicity leased and is never implicitly assumed.","title":"Description"},{"location":"#software-stack","text":"The stack integrates simulation, middleware, and layed autonomy logic for both development and eventual hardware deployment. Cosys-AirSim serves as the primary simulation environment (although Gazebo can work just as well for your implementation), providing high-fidelity rendering, physics, and sensor simulation, allowing for photo realistic testing and iteration without physical hardware. The companion computer communicates bidirectionally with the PX4 flight controller via uXRCE-DDS (the ROS2 bridge for PX4's uORB topics). This allows the autonomy stack to subscribe to vehicle state/telemetry and publish Offboard commands. Cosys-AirSim includes a ROS2 wrapper that bridges simulation sensor data into standard ROS2 topics, making it easy to feed behavior nodes. The autonomy logic itself is structued in three decoupled layers (read more in Architecture section). Supervisor Layer: continuous monitors system health, PX4 failsafe flags, node liveliness, resource usage, and environmental constraints. It leases autonomy to the control layer only when strict safety preconditions are met. Control Layer: enforced by the lease gate, validates and filters all outgoing commands, maintains communication with the PX4 flight controller, and falls back to safe hold setpoints when the lease is revoked. Decision Layer: generates high-level intent via composable behavior trees. It has no direct actuation authority as all outputs pass through validation and gating.","title":"Software Stack"},{"location":"#table-of-contents","text":"","title":"Table of Contents"},{"location":"architecture/control/","text":"Control Layer The control layer converts a single intent stream from the decision layer into PX4-compatible flight commands when authorized bt the lease gate. It enforces safe boundaries and maintains the offboard handshake regardless of authorization state. Offboard Interface The control layer must maintain a handshake with the flight controller in order to obtain offboard control. Lease Gate Intent Validation Directive Handling Directives from the supervisor bypass intent validation and take absolute priority over decision layer intents. Arbitrating Intent The decision layer is repsonsible for producing a single intent stream via behavior tree arbitration. The control layer receieves this intent as-is, so no further arbitration is needed at the control layer. Read the decison layer page for more information.","title":"Control Layer"},{"location":"architecture/control/#control-layer","text":"The control layer converts a single intent stream from the decision layer into PX4-compatible flight commands when authorized bt the lease gate. It enforces safe boundaries and maintains the offboard handshake regardless of authorization state.","title":"Control Layer"},{"location":"architecture/control/#offboard-interface","text":"The control layer must maintain a handshake with the flight controller in order to obtain offboard control.","title":"Offboard Interface"},{"location":"architecture/control/#lease-gate","text":"","title":"Lease Gate"},{"location":"architecture/control/#intent-validation","text":"","title":"Intent Validation"},{"location":"architecture/control/#directive-handling","text":"Directives from the supervisor bypass intent validation and take absolute priority over decision layer intents.","title":"Directive Handling"},{"location":"architecture/control/#arbitrating-intent","text":"The decision layer is repsonsible for producing a single intent stream via behavior tree arbitration. The control layer receieves this intent as-is, so no further arbitration is needed at the control layer. Read the decison layer page for more information.","title":"Arbitrating Intent"},{"location":"architecture/decision/","text":"Decision Layers","title":"Decision Layer"},{"location":"architecture/decision/#decision-layers","text":"","title":"Decision Layers"},{"location":"architecture/lifecycle/","text":"Node Lifecycles","title":"System Lifecycles"},{"location":"architecture/lifecycle/#node-lifecycles","text":"","title":"Node Lifecycles"},{"location":"architecture/overview/","text":"UAV Lease-Gated Autonomy Stack This section provides a high-level overview of the UAV Lease-Gated Autonomy Stack , a software archiecture built on top of ROS2 for autonomous drone systems. The core design philosphy is explicit, revocable authorization and deterministic safety enforcement, seperating concerns of system health monitoring, control, and decision-making. The Lease Gate The system is built around the concept of a Lease Gate. It is a time-bounded authorization barrier that permits drone autonomy. The lease exists in the following two states: Granted : When a valid, unexpired lease is active, authorized control commands are allowed to pass through to the FC. Revoked/Expired : The gate immediately blocks all actuation commands. The control software must cease and may only hold position or execute predefined safe behavior. A lease is a short-lived token granted by the supervisor only when a strict set of safety preconditions are met. This ensures that autonomy is never assumed, but always permitted within a known-safe envelope. Layers of the Stack The stack is logically divided into three distinct layers: Supervisor Layer , Control Layer , and the Decision Layer . Each with a specific responsibility and well defined interfaces between them. Supervisor Layer The supervisor is the ultimate authority for autonomous operation. It coninuously monitors the entire system and decides if and under what constraints autonomy is allowed. When a fault is detected, the supervisor is responsible for enforcing the appropriate responsed according to predefiend policy. Lease Manager : Responsible for granting or revoking control leases to the control layer. Lease is granted under certain preconditions and if those preconditions fail, the lease is revoked. Health Monitor : Responsible for verifying the liveliness of the decision and control layers, monitoring the control loop, watching for FC failsafe flags, monitoring CC resources, and fault handling. Fault Handler : Executes predefined response policies when faults are detected such as mode switching, lease revocation, and emergency procedures. If PX4 leaves OFFBOARD mode due to RC override, internal failsafe, or manual mode switch the supervisor immediately revokes any active leases. Control Layer The control layer is responsible for converting high-level intent actions into FC compatible commands when authorized through a lease. Lease Gate : Only passes actuation commands when the lease is valid. Intent Arbiter : Processes the single intent stream from the decision layer, applying priority and envelope checks. Intent Validation : Applies detemrinistic safety filters to all commands, ensuring they remain within the vehicle's physical limits, geofence boundaries, and operational constraints. FC Offboard Interface : Maintains the PX4 offboard handshake (2Hz minimum heartbeat) and executes a fixed-rate control loop (20-50Hz). Publishes safe hold setpoints when autonomy is not authorized. Decision Layer The deicison layer determines what the vehicle should do based on mission objectives, sensor data, and environmental context. Behavior Tree Engine : Executes modular, composable behaviors with priority-based arbitration. Higher-priority safet behaviors can preempt mission tasks. TODO The decison layer produces advisory intent only, it has no direct command authority. All intent must pass through the control layer's safety validation and lease gating.","title":"Overview"},{"location":"architecture/overview/#uav-lease-gated-autonomy-stack","text":"This section provides a high-level overview of the UAV Lease-Gated Autonomy Stack , a software archiecture built on top of ROS2 for autonomous drone systems. The core design philosphy is explicit, revocable authorization and deterministic safety enforcement, seperating concerns of system health monitoring, control, and decision-making.","title":"UAV Lease-Gated Autonomy Stack"},{"location":"architecture/overview/#the-lease-gate","text":"The system is built around the concept of a Lease Gate. It is a time-bounded authorization barrier that permits drone autonomy. The lease exists in the following two states: Granted : When a valid, unexpired lease is active, authorized control commands are allowed to pass through to the FC. Revoked/Expired : The gate immediately blocks all actuation commands. The control software must cease and may only hold position or execute predefined safe behavior. A lease is a short-lived token granted by the supervisor only when a strict set of safety preconditions are met. This ensures that autonomy is never assumed, but always permitted within a known-safe envelope.","title":"The Lease Gate"},{"location":"architecture/overview/#layers-of-the-stack","text":"The stack is logically divided into three distinct layers: Supervisor Layer , Control Layer , and the Decision Layer . Each with a specific responsibility and well defined interfaces between them.","title":"Layers of the Stack"},{"location":"architecture/overview/#supervisor-layer","text":"The supervisor is the ultimate authority for autonomous operation. It coninuously monitors the entire system and decides if and under what constraints autonomy is allowed. When a fault is detected, the supervisor is responsible for enforcing the appropriate responsed according to predefiend policy. Lease Manager : Responsible for granting or revoking control leases to the control layer. Lease is granted under certain preconditions and if those preconditions fail, the lease is revoked. Health Monitor : Responsible for verifying the liveliness of the decision and control layers, monitoring the control loop, watching for FC failsafe flags, monitoring CC resources, and fault handling. Fault Handler : Executes predefined response policies when faults are detected such as mode switching, lease revocation, and emergency procedures. If PX4 leaves OFFBOARD mode due to RC override, internal failsafe, or manual mode switch the supervisor immediately revokes any active leases.","title":"Supervisor Layer"},{"location":"architecture/overview/#control-layer","text":"The control layer is responsible for converting high-level intent actions into FC compatible commands when authorized through a lease. Lease Gate : Only passes actuation commands when the lease is valid. Intent Arbiter : Processes the single intent stream from the decision layer, applying priority and envelope checks. Intent Validation : Applies detemrinistic safety filters to all commands, ensuring they remain within the vehicle's physical limits, geofence boundaries, and operational constraints. FC Offboard Interface : Maintains the PX4 offboard handshake (2Hz minimum heartbeat) and executes a fixed-rate control loop (20-50Hz). Publishes safe hold setpoints when autonomy is not authorized.","title":"Control Layer"},{"location":"architecture/overview/#decision-layer","text":"The deicison layer determines what the vehicle should do based on mission objectives, sensor data, and environmental context. Behavior Tree Engine : Executes modular, composable behaviors with priority-based arbitration. Higher-priority safet behaviors can preempt mission tasks. TODO The decison layer produces advisory intent only, it has no direct command authority. All intent must pass through the control layer's safety validation and lease gating.","title":"Decision Layer"},{"location":"architecture/supervisor/","text":"Supervisor/Watchdog Layer The supervisor is the safety authority of the companion computer. It determines whether autonomy is allowed to act, under what constraints can autonomy act, and what actions must occur to keep the drone in a safe state. The architecture is designed around the PX4 authority model which treats offboard control as advisory, revocable and non-authoritative. PX4 Authority model The PX4 authority model refers to which source (pilot, internal autopilot, companion computer, etc.) has control over the vehicle at any given time, and under what conditions can that authority be granted, shared, or revoked. PX4 operates in discrete flight modes (Land, Return, Offboard, Mission) and each determines who provides the setpoints and how much authority the autopilot has over actuators. Offboard mode is the important mode for companion computers. The external system sends setpoints via MAVLink/uXRCE-DDS. PX4 delegates low-level control to these external setpoints while still running its internal rate/attitude controllers. Even in offboard mode PX4 retains override authority for failsafes, RC override, and internal safety checks. The companion computer only has high-level setpoint authority. Supervisor Position in Stack The Supervisor sits above the Control and Decision layers in terms of authority, but has a different set of responsibilities The decision layer decides what the system would like to do. The control layer decides how to safety express those decision to the flight controller. The supervisor decide whether either of those layers is allowed to influence the vehicle at all. The supervisor's responsiblity is to authorize autonomy, send explicit directives to the control layer to perform safe actions, and classify faults to determine what directive to take. The supervisor does not have direct communication to the flight controller so if the supervisor needs to perform an action in the name of safety it must do so through control layer directives. Lease Manager The lease manager is the supervisor's primary enforcement mechanism for the execution of autonomy in the stack. The lease manager has the following responsibilities: Grant leases to the control layer when certain preconditions are met. Periodically renew leases while conditions remain valid. Revoke leases. Examples of reasons to revoke a lease: safety violation, fault classification requiring loss of autonomy, loss of heartbeat from control or decision layers, or PX4 flightmode change out of offboard. Each layer that is under the Supervisor is lease-gated. The control layer is lease-gated from actuation (commands send to PX4 based off of intent by the decision layer) and the decision layer is gated from sending intent to the control layer. Control layer will still be able to send fallback setpoints to the flight controller even if the lease is invalid, it will also send commands to maintain the handshake between the control layer and the flight controller. The lease only gates commands that was previously intent from the decision layer. Preconditions for granting/renewing a lease, and how long is a lease and when does it get renewed is dependent on implementation. For the example implementation of the framework the lease is implemented as follows: TODO Health Monitoring The supervisor continuously monitors the health of the software running in the stack, the hardware that the stack is running on, and the condition of the flight controller. Monitors heartbeats from the control and decision layer. Heartbeat loss is treated as a fault and will be handled in fault classification. Monitor the control loop in the control layer to ensure that timing is being met. Monitor vehicle health given information from the flight controller. This could include failsafe flags, estimator validity, change in flight mode, etc. Monitor hardware system health. This includes CPU load, memory ussage, or sensor uptime. If any of these systems are not within acceptable values a fault is generated and handled by the fault classifier. Fault Classification A fault is any observed condition that invalidates on ror more safety assumptions required for safe autonomous operation. Faults can originate from: Interal stack monitoring (e.g. heartbeat loss, control-loop timing violation, high CPU/memory usage) PX4 telemetry (e.g. asserted failsafe flags, estimator rejections, invalid positions). Other nodes (e.g., perception pipeline detects an imminent collision or geofence violation) A warning is an observed condition that does not yet invalidate safety assumptions but is logged for information or predicitve purposes. The supervisor is the sole authority for classifying incoming faults and deciding the response. Classification follows a severity based match-and-action model: Receieve the fault report. Match the fault type/code against predfined severity levels. Execute the corresponding directive. A directive is a high priority command sent to the control layer. Directives have absolute precedence over any intent from the decision layer. The control layer must honor the directive while preserving the offboard handshake. Example severity levels and directives (customizable per implementation): ** TODO** Directives are explicit messages that instruct the control layer to: Transition to a specific PX4 mode. Publish fallback setpoints. Execute predfined safe behaviors. Ignore decision layer intent until cleared. Supervisor required Topics /fmu/out/failsafe_flags timestamp: 1769017538192250 mode_req_angular_velocity: 8312190 mode_req_attitude: 8311166 mode_req_local_alt: 8257918 mode_req_local_position: 7995448 mode_req_local_position_relaxed: 262212 mode_req_global_position: 56 mode_req_global_position_relaxed: 0 mode_req_mission: 8 mode_req_offboard_signal: 16384 mode_req_home_position: 32 mode_req_wind_and_flight_time_compliance: 2621464 mode_req_prevent_arming: 3944480 mode_req_manual_control: 34119 mode_req_other: 2139095040 angular_velocity_invalid: false attitude_invalid: false local_altitude_invalid: false local_position_invalid: false local_position_invalid_relaxed: false local_velocity_invalid: false global_position_invalid: false global_position_invalid_relaxed: false auto_mission_missing: true offboard_control_signal_lost: true home_position_invalid: false manual_control_signal_lost: true gcs_connection_lost: true battery_warning: 0 battery_low_remaining_time: false battery_unhealthy: false geofence_breached: false mission_failure: false vtol_fixed_wing_system_failure: false wind_limit_exceeded: false flight_time_limit_exceeded: false position_accuracy_low: false navigator_failure: false fd_critical_failure: false fd_esc_arming_failure: false fd_imbalanced_prop: false fd_motor_failure: false /fmu/out/vehicle_status_v1 timestamp: 1769017639546586 armed_time: 1769017626134683 takeoff_time: 1769017627946722 arming_state: 2 latest_arming_reason: 3 latest_disarming_reason: 0 nav_state_timestamp: 1769017632590821 nav_state_user_intention: 4 nav_state: 4 executor_in_charge: 0 valid_nav_states_mask: 2147411327 can_set_nav_states_mask: 8308095 failure_detector_status: 0 hil_state: 0 vehicle_type: 1 failsafe: false failsafe_and_user_took_over: false failsafe_defer_state: 0 gcs_connection_lost: true gcs_connection_lost_counter: 0 high_latency_data_link_lost: false is_vtol: false is_vtol_tailsitter: false in_transition_mode: false in_transition_to_fw: false system_type: 2 system_id: 1 component_id: 1 safety_button_available: true safety_off: true power_input_valid: true usb_connected: false open_drone_id_system_present: false open_drone_id_system_healthy: false parachute_system_present: false parachute_system_healthy: false rc_calibration_in_progress: false calibration_enabled: false pre_flight_checks_pass: true /fmu/out/estimator_status_flags timestamp: 1769017692429033 timestamp_sample: 1769017692258029 control_status_changes: 15 cs_tilt_align: true cs_yaw_align: true cs_gnss_pos: true cs_opt_flow: false cs_mag_hdg: false cs_mag_3d: true cs_mag_dec: false cs_in_air: true cs_wind: false cs_baro_hgt: true cs_rng_hgt: false cs_gps_hgt: true cs_ev_pos: false cs_ev_yaw: false cs_ev_hgt: false cs_fuse_beta: false cs_mag_field_disturbed: false cs_fixed_wing: false cs_mag_fault: false cs_fuse_aspd: false cs_gnd_effect: false cs_rng_stuck: false cs_gnss_yaw: false cs_mag_aligned_in_flight: true cs_ev_vel: false cs_synthetic_mag_z: false cs_vehicle_at_rest: false cs_gnss_yaw_fault: false cs_rng_fault: false cs_inertial_dead_reckoning: false cs_wind_dead_reckoning: false cs_rng_kin_consistent: false cs_fake_pos: false cs_fake_hgt: false cs_gravity_vector: false cs_mag: true cs_ev_yaw_fault: false cs_mag_heading_consistent: true cs_aux_gpos: false cs_rng_terrain: false cs_opt_flow_terrain: false cs_valid_fake_pos: false cs_constant_pos: false cs_baro_fault: false cs_gnss_vel: true cs_gnss_fault: false cs_yaw_manual: false cs_gnss_hgt_fault: false fault_status_changes: 0 fs_bad_mag_x: false fs_bad_mag_y: false fs_bad_mag_z: false fs_bad_hdg: false fs_bad_mag_decl: false fs_bad_airspeed: false fs_bad_sideslip: false fs_bad_optflow_x: false fs_bad_optflow_y: false fs_bad_acc_vertical: false fs_bad_acc_clipping: false innovation_fault_status_changes: 4 reject_hor_vel: false reject_ver_vel: false reject_hor_pos: false reject_ver_pos: false reject_yaw: false reject_airspeed: false reject_sideslip: false reject_hagl: false reject_optflow_x: false reject_optflow_y: false /fmu/out/vehicle_land_detected timestamp: 1769017743973002 freefall: false ground_contact: true maybe_landed: true landed: true in_ground_effect: true in_descend: true has_low_throttle: true vertical_movement: false horizontal_movement: false rotational_movement: false close_to_ground_or_skipped_check: true at_rest: true","title":"Supervisor"},{"location":"architecture/supervisor/#supervisorwatchdog-layer","text":"The supervisor is the safety authority of the companion computer. It determines whether autonomy is allowed to act, under what constraints can autonomy act, and what actions must occur to keep the drone in a safe state. The architecture is designed around the PX4 authority model which treats offboard control as advisory, revocable and non-authoritative.","title":"Supervisor/Watchdog Layer"},{"location":"architecture/supervisor/#px4-authority-model","text":"The PX4 authority model refers to which source (pilot, internal autopilot, companion computer, etc.) has control over the vehicle at any given time, and under what conditions can that authority be granted, shared, or revoked. PX4 operates in discrete flight modes (Land, Return, Offboard, Mission) and each determines who provides the setpoints and how much authority the autopilot has over actuators. Offboard mode is the important mode for companion computers. The external system sends setpoints via MAVLink/uXRCE-DDS. PX4 delegates low-level control to these external setpoints while still running its internal rate/attitude controllers. Even in offboard mode PX4 retains override authority for failsafes, RC override, and internal safety checks. The companion computer only has high-level setpoint authority.","title":"PX4 Authority model"},{"location":"architecture/supervisor/#supervisor-position-in-stack","text":"The Supervisor sits above the Control and Decision layers in terms of authority, but has a different set of responsibilities The decision layer decides what the system would like to do. The control layer decides how to safety express those decision to the flight controller. The supervisor decide whether either of those layers is allowed to influence the vehicle at all. The supervisor's responsiblity is to authorize autonomy, send explicit directives to the control layer to perform safe actions, and classify faults to determine what directive to take. The supervisor does not have direct communication to the flight controller so if the supervisor needs to perform an action in the name of safety it must do so through control layer directives.","title":"Supervisor Position in Stack"},{"location":"architecture/supervisor/#lease-manager","text":"The lease manager is the supervisor's primary enforcement mechanism for the execution of autonomy in the stack. The lease manager has the following responsibilities: Grant leases to the control layer when certain preconditions are met. Periodically renew leases while conditions remain valid. Revoke leases. Examples of reasons to revoke a lease: safety violation, fault classification requiring loss of autonomy, loss of heartbeat from control or decision layers, or PX4 flightmode change out of offboard. Each layer that is under the Supervisor is lease-gated. The control layer is lease-gated from actuation (commands send to PX4 based off of intent by the decision layer) and the decision layer is gated from sending intent to the control layer. Control layer will still be able to send fallback setpoints to the flight controller even if the lease is invalid, it will also send commands to maintain the handshake between the control layer and the flight controller. The lease only gates commands that was previously intent from the decision layer. Preconditions for granting/renewing a lease, and how long is a lease and when does it get renewed is dependent on implementation. For the example implementation of the framework the lease is implemented as follows: TODO","title":"Lease Manager"},{"location":"architecture/supervisor/#health-monitoring","text":"The supervisor continuously monitors the health of the software running in the stack, the hardware that the stack is running on, and the condition of the flight controller. Monitors heartbeats from the control and decision layer. Heartbeat loss is treated as a fault and will be handled in fault classification. Monitor the control loop in the control layer to ensure that timing is being met. Monitor vehicle health given information from the flight controller. This could include failsafe flags, estimator validity, change in flight mode, etc. Monitor hardware system health. This includes CPU load, memory ussage, or sensor uptime. If any of these systems are not within acceptable values a fault is generated and handled by the fault classifier.","title":"Health Monitoring"},{"location":"architecture/supervisor/#fault-classification","text":"A fault is any observed condition that invalidates on ror more safety assumptions required for safe autonomous operation. Faults can originate from: Interal stack monitoring (e.g. heartbeat loss, control-loop timing violation, high CPU/memory usage) PX4 telemetry (e.g. asserted failsafe flags, estimator rejections, invalid positions). Other nodes (e.g., perception pipeline detects an imminent collision or geofence violation) A warning is an observed condition that does not yet invalidate safety assumptions but is logged for information or predicitve purposes. The supervisor is the sole authority for classifying incoming faults and deciding the response. Classification follows a severity based match-and-action model: Receieve the fault report. Match the fault type/code against predfined severity levels. Execute the corresponding directive. A directive is a high priority command sent to the control layer. Directives have absolute precedence over any intent from the decision layer. The control layer must honor the directive while preserving the offboard handshake. Example severity levels and directives (customizable per implementation): ** TODO** Directives are explicit messages that instruct the control layer to: Transition to a specific PX4 mode. Publish fallback setpoints. Execute predfined safe behaviors. Ignore decision layer intent until cleared.","title":"Fault Classification"},{"location":"architecture/supervisor/#supervisor-required-topics","text":"/fmu/out/failsafe_flags timestamp: 1769017538192250 mode_req_angular_velocity: 8312190 mode_req_attitude: 8311166 mode_req_local_alt: 8257918 mode_req_local_position: 7995448 mode_req_local_position_relaxed: 262212 mode_req_global_position: 56 mode_req_global_position_relaxed: 0 mode_req_mission: 8 mode_req_offboard_signal: 16384 mode_req_home_position: 32 mode_req_wind_and_flight_time_compliance: 2621464 mode_req_prevent_arming: 3944480 mode_req_manual_control: 34119 mode_req_other: 2139095040 angular_velocity_invalid: false attitude_invalid: false local_altitude_invalid: false local_position_invalid: false local_position_invalid_relaxed: false local_velocity_invalid: false global_position_invalid: false global_position_invalid_relaxed: false auto_mission_missing: true offboard_control_signal_lost: true home_position_invalid: false manual_control_signal_lost: true gcs_connection_lost: true battery_warning: 0 battery_low_remaining_time: false battery_unhealthy: false geofence_breached: false mission_failure: false vtol_fixed_wing_system_failure: false wind_limit_exceeded: false flight_time_limit_exceeded: false position_accuracy_low: false navigator_failure: false fd_critical_failure: false fd_esc_arming_failure: false fd_imbalanced_prop: false fd_motor_failure: false /fmu/out/vehicle_status_v1 timestamp: 1769017639546586 armed_time: 1769017626134683 takeoff_time: 1769017627946722 arming_state: 2 latest_arming_reason: 3 latest_disarming_reason: 0 nav_state_timestamp: 1769017632590821 nav_state_user_intention: 4 nav_state: 4 executor_in_charge: 0 valid_nav_states_mask: 2147411327 can_set_nav_states_mask: 8308095 failure_detector_status: 0 hil_state: 0 vehicle_type: 1 failsafe: false failsafe_and_user_took_over: false failsafe_defer_state: 0 gcs_connection_lost: true gcs_connection_lost_counter: 0 high_latency_data_link_lost: false is_vtol: false is_vtol_tailsitter: false in_transition_mode: false in_transition_to_fw: false system_type: 2 system_id: 1 component_id: 1 safety_button_available: true safety_off: true power_input_valid: true usb_connected: false open_drone_id_system_present: false open_drone_id_system_healthy: false parachute_system_present: false parachute_system_healthy: false rc_calibration_in_progress: false calibration_enabled: false pre_flight_checks_pass: true /fmu/out/estimator_status_flags timestamp: 1769017692429033 timestamp_sample: 1769017692258029 control_status_changes: 15 cs_tilt_align: true cs_yaw_align: true cs_gnss_pos: true cs_opt_flow: false cs_mag_hdg: false cs_mag_3d: true cs_mag_dec: false cs_in_air: true cs_wind: false cs_baro_hgt: true cs_rng_hgt: false cs_gps_hgt: true cs_ev_pos: false cs_ev_yaw: false cs_ev_hgt: false cs_fuse_beta: false cs_mag_field_disturbed: false cs_fixed_wing: false cs_mag_fault: false cs_fuse_aspd: false cs_gnd_effect: false cs_rng_stuck: false cs_gnss_yaw: false cs_mag_aligned_in_flight: true cs_ev_vel: false cs_synthetic_mag_z: false cs_vehicle_at_rest: false cs_gnss_yaw_fault: false cs_rng_fault: false cs_inertial_dead_reckoning: false cs_wind_dead_reckoning: false cs_rng_kin_consistent: false cs_fake_pos: false cs_fake_hgt: false cs_gravity_vector: false cs_mag: true cs_ev_yaw_fault: false cs_mag_heading_consistent: true cs_aux_gpos: false cs_rng_terrain: false cs_opt_flow_terrain: false cs_valid_fake_pos: false cs_constant_pos: false cs_baro_fault: false cs_gnss_vel: true cs_gnss_fault: false cs_yaw_manual: false cs_gnss_hgt_fault: false fault_status_changes: 0 fs_bad_mag_x: false fs_bad_mag_y: false fs_bad_mag_z: false fs_bad_hdg: false fs_bad_mag_decl: false fs_bad_airspeed: false fs_bad_sideslip: false fs_bad_optflow_x: false fs_bad_optflow_y: false fs_bad_acc_vertical: false fs_bad_acc_clipping: false innovation_fault_status_changes: 4 reject_hor_vel: false reject_ver_vel: false reject_hor_pos: false reject_ver_pos: false reject_yaw: false reject_airspeed: false reject_sideslip: false reject_hagl: false reject_optflow_x: false reject_optflow_y: false /fmu/out/vehicle_land_detected timestamp: 1769017743973002 freefall: false ground_contact: true maybe_landed: true landed: true in_ground_effect: true in_descend: true has_low_throttle: true vertical_movement: false horizontal_movement: false rotational_movement: false close_to_ground_or_skipped_check: true at_rest: true","title":"Supervisor required Topics"},{"location":"getting-started/configuration/","text":"Example Cosys-AirSim Settings Example settings.json { \"SettingsVersion\": 2.0, \"SimMode\": \"Multirotor\", \"ClockType\": \"SteppableClock\", \"Vehicles\": { \"PX4\": { \"VehicleType\": \"PX4Multirotor\", \"UseSerial\": false, \"LockStep\": true, \"UseTcp\": true, \"TcpPort\": 4560, \"ControlIp\": \"192.168.128.1\", \"ControlPortLocal\": 14540, \"ControlPortRemote\": 14580, \"LocalHostIp\": \"192.168.128.1\", \"Sensors\":{ \"Barometer\":{ \"SensorType\": 1, \"Enabled\": true, \"PressureFactorSigma\": 0.0001825 }, \"Lidar1\": { \"SensorType\": 6, \"Enabled\" : true, \"NumberOfChannels\": 16, \"PointsPerSecond\": 10000, \"X\": 0, \"Y\": 0, \"Z\": -1, \"DrawDebugPoints\": false } }, \"Cameras\": { \"FrontCam\": { \"CaptureSettings\": [ { \"ImageType\": 0, \"Width\": 640, \"Height\": 480, \"FOV_Degrees\": 90, \"AutoExposureSpeed\": 100, \"AutoExposureBias\": 0, \"AutoExposureMaxBrightness\": 0.64, \"AutoExposureMinBrightness\": 0.03, \"MotionBlurAmount\": 0, \"TargetGamma\": 1.0 } ], \"X\": 0, \"Y\": 0.0, \"Z\": 0.20, \"Pitch\": -10.00, \"Roll\": 0.0, \"Yaw\": 0.0 } }, \"Parameters\": { \"NAV_RCL_ACT\": 0, \"NAV_DLL_ACT\": 0, \"COM_OBL_ACT\": 1, \"LPE_LAT\": 47.641468, \"LPE_LON\": -122.140165 } } } }","title":"Configuration"},{"location":"getting-started/configuration/#example-cosys-airsim-settings","text":"Example settings.json { \"SettingsVersion\": 2.0, \"SimMode\": \"Multirotor\", \"ClockType\": \"SteppableClock\", \"Vehicles\": { \"PX4\": { \"VehicleType\": \"PX4Multirotor\", \"UseSerial\": false, \"LockStep\": true, \"UseTcp\": true, \"TcpPort\": 4560, \"ControlIp\": \"192.168.128.1\", \"ControlPortLocal\": 14540, \"ControlPortRemote\": 14580, \"LocalHostIp\": \"192.168.128.1\", \"Sensors\":{ \"Barometer\":{ \"SensorType\": 1, \"Enabled\": true, \"PressureFactorSigma\": 0.0001825 }, \"Lidar1\": { \"SensorType\": 6, \"Enabled\" : true, \"NumberOfChannels\": 16, \"PointsPerSecond\": 10000, \"X\": 0, \"Y\": 0, \"Z\": -1, \"DrawDebugPoints\": false } }, \"Cameras\": { \"FrontCam\": { \"CaptureSettings\": [ { \"ImageType\": 0, \"Width\": 640, \"Height\": 480, \"FOV_Degrees\": 90, \"AutoExposureSpeed\": 100, \"AutoExposureBias\": 0, \"AutoExposureMaxBrightness\": 0.64, \"AutoExposureMinBrightness\": 0.03, \"MotionBlurAmount\": 0, \"TargetGamma\": 1.0 } ], \"X\": 0, \"Y\": 0.0, \"Z\": 0.20, \"Pitch\": -10.00, \"Roll\": 0.0, \"Yaw\": 0.0 } }, \"Parameters\": { \"NAV_RCL_ACT\": 0, \"NAV_DLL_ACT\": 0, \"COM_OBL_ACT\": 1, \"LPE_LAT\": 47.641468, \"LPE_LON\": -122.140165 } } } }","title":"Example Cosys-AirSim Settings"},{"location":"getting-started/installation/","text":"Installation Guide This guide is for a Windows 11 environment. WSL2 Setup (Ubuntu 22.04 LTS) Open PowerShell as administrator and install Ubuntu-22.04. wsl --install -d Ubuntu-22.04 Open WSL. wsl -d Ubuntu-22.04 Install the essentials. sudo apt update && sudo apt upgrade -y sudo apt install -y build-essential cmake git Install PX4 Read PX4 ROS2 User Guide for more details. cd ~ git clone https://github.com/PX4/PX4-Autopilot.git --recursive bash ./PX4-Autopilot/Tools/setup/ubuntu.sh cd PX4-Autopilot/ make px4_sitl If you get this error regarding protoc, you must download and compile protoc 3.6.1 from source manually. Otherwise, skip this section. (Referenced from \"Protoc error on build\" forum post on discuss.px4.io). /usr/include/gz/msgs10/gz/msgs/details/serialized.pb.h:12:2: error: #error This file was generated by a newer version of protoc which is 12 | #error This file was generated by a newer version of protoc which is | ^~~~~ Remove existing Protobuf version. sudo apt-get remove --purge protobuf-compiler libprotobuf-dev sudo apt-get autoremove Download and compile protoc 3.6.1 from source. cd ~ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz tar -xzf protobuf-all-3.6.1.tar.gz cd protobuf-3.6.1 ./configure --prefix=/usr/local make -j$(nproc) sudo make install sudo ldconfig Verify installation (it should be 3.6.1 now). protoc --version Clean PX4 project directory. cd ~/PX4-Autopilot make distclean Restart WSL exit Shutdown. wsl --shutdown Wait a few seceonds then open a new WSL terminal. wsl -d Ubuntu-22.04 Try the build again: cd ~/PX4-Autopilot/ make px4_sitl Install ROS2 Install ROS2 Humble on Ubuntu 22.04. cd ~ sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 sudo apt install software-properties-common sudo add-apt-repository universe sudo apt update && sudo apt install curl -y sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update && sudo apt upgrade -y sudo apt install ros-humble-desktop sudo apt install ros-dev-tools source /opt/ros/humble/setup.bash && echo \"source /opt/ros/humble/setup.bash\" >> .bashrc Install some missing dependencies. pip install --user -U empy==3.3.4 pyros-genmsg setuptools Setup Micro XRCE-DSS uXRCE-DDS allows the PX4 flight controller to natively participate in a ROS2 DDS network. The client runs on PX4, which communicates with an agent on the ROS2 companion computer. cd ~ git clone -b v2.4.3 https://github.com/eProsima/Micro-XRCE-DDS-Agent.git cd Micro-XRCE-DDS-Agent mkdir build cd build cmake .. make sudo make install sudo ldconfig /usr/local/lib/ cd ~ Start the agent. MicroXRCEAgent udp4 -p 8888 AirSim Setup For this project we will be using Cosys-AirSim as our simulator, a similar set up can be accomplished with other simulators like Gazebo. Cosys-AirSim comes with a ROS2 wrapper that will allow us to read sensor data from the simulator. Install Cosys-AirSim Configure AirSim plugin for PX4 Most connection issues between UE5 on your local windows machine and the flight controller in WSL2 can be fixed by adding inbound rules to the connection ports and to UE5. Add inbound rules for TCP 4560 , UDP 14540 , and Unreal Engine . Download Template Source Code Run Order Run these commands in seperate terminals. Cosys-AirSim (Windows) uXRCE-DDS (WSL2) MicroXRCEAgent udp4 -p 8888 PX4 SITL (WSL2) cd ~/PX4-Autopilot make px4_sitl none_iris AirSim ROS2 Wrapper (WSL2) source ~/Cosys-AirSim/ros2/install/setup.bash ros2 launch airsim_ros_pkgs airsim_node.launch.py host_ip:=192.168.128.1 Double check ros2 topic list to see if all the important nodes are running. You should see /airsim_node/* and /fmu/* topics. Framework Template Nodes (WSL2) Additional Resources PX4 ROS2 User Guide Protoc error on build Cosys-AirSim Docs","title":"Installation"},{"location":"getting-started/installation/#installation-guide","text":"This guide is for a Windows 11 environment.","title":"Installation Guide"},{"location":"getting-started/installation/#wsl2-setup-ubuntu-2204-lts","text":"Open PowerShell as administrator and install Ubuntu-22.04. wsl --install -d Ubuntu-22.04 Open WSL. wsl -d Ubuntu-22.04 Install the essentials. sudo apt update && sudo apt upgrade -y sudo apt install -y build-essential cmake git","title":"WSL2 Setup (Ubuntu 22.04 LTS)"},{"location":"getting-started/installation/#install-px4","text":"Read PX4 ROS2 User Guide for more details. cd ~ git clone https://github.com/PX4/PX4-Autopilot.git --recursive bash ./PX4-Autopilot/Tools/setup/ubuntu.sh cd PX4-Autopilot/ make px4_sitl If you get this error regarding protoc, you must download and compile protoc 3.6.1 from source manually. Otherwise, skip this section. (Referenced from \"Protoc error on build\" forum post on discuss.px4.io). /usr/include/gz/msgs10/gz/msgs/details/serialized.pb.h:12:2: error: #error This file was generated by a newer version of protoc which is 12 | #error This file was generated by a newer version of protoc which is | ^~~~~ Remove existing Protobuf version. sudo apt-get remove --purge protobuf-compiler libprotobuf-dev sudo apt-get autoremove Download and compile protoc 3.6.1 from source. cd ~ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz tar -xzf protobuf-all-3.6.1.tar.gz cd protobuf-3.6.1 ./configure --prefix=/usr/local make -j$(nproc) sudo make install sudo ldconfig Verify installation (it should be 3.6.1 now). protoc --version Clean PX4 project directory. cd ~/PX4-Autopilot make distclean Restart WSL exit Shutdown. wsl --shutdown Wait a few seceonds then open a new WSL terminal. wsl -d Ubuntu-22.04 Try the build again: cd ~/PX4-Autopilot/ make px4_sitl","title":"Install PX4"},{"location":"getting-started/installation/#install-ros2","text":"Install ROS2 Humble on Ubuntu 22.04. cd ~ sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 sudo apt install software-properties-common sudo add-apt-repository universe sudo apt update && sudo apt install curl -y sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update && sudo apt upgrade -y sudo apt install ros-humble-desktop sudo apt install ros-dev-tools source /opt/ros/humble/setup.bash && echo \"source /opt/ros/humble/setup.bash\" >> .bashrc Install some missing dependencies. pip install --user -U empy==3.3.4 pyros-genmsg setuptools","title":"Install ROS2"},{"location":"getting-started/installation/#setup-micro-xrce-dss","text":"uXRCE-DDS allows the PX4 flight controller to natively participate in a ROS2 DDS network. The client runs on PX4, which communicates with an agent on the ROS2 companion computer. cd ~ git clone -b v2.4.3 https://github.com/eProsima/Micro-XRCE-DDS-Agent.git cd Micro-XRCE-DDS-Agent mkdir build cd build cmake .. make sudo make install sudo ldconfig /usr/local/lib/ cd ~ Start the agent. MicroXRCEAgent udp4 -p 8888","title":"Setup Micro XRCE-DSS"},{"location":"getting-started/installation/#airsim-setup","text":"For this project we will be using Cosys-AirSim as our simulator, a similar set up can be accomplished with other simulators like Gazebo. Cosys-AirSim comes with a ROS2 wrapper that will allow us to read sensor data from the simulator. Install Cosys-AirSim Configure AirSim plugin for PX4 Most connection issues between UE5 on your local windows machine and the flight controller in WSL2 can be fixed by adding inbound rules to the connection ports and to UE5. Add inbound rules for TCP 4560 , UDP 14540 , and Unreal Engine .","title":"AirSim Setup"},{"location":"getting-started/installation/#download-template-source-code","text":"","title":"Download Template Source Code"},{"location":"getting-started/installation/#run-order","text":"Run these commands in seperate terminals. Cosys-AirSim (Windows) uXRCE-DDS (WSL2) MicroXRCEAgent udp4 -p 8888 PX4 SITL (WSL2) cd ~/PX4-Autopilot make px4_sitl none_iris AirSim ROS2 Wrapper (WSL2) source ~/Cosys-AirSim/ros2/install/setup.bash ros2 launch airsim_ros_pkgs airsim_node.launch.py host_ip:=192.168.128.1 Double check ros2 topic list to see if all the important nodes are running. You should see /airsim_node/* and /fmu/* topics. Framework Template Nodes (WSL2)","title":"Run Order"},{"location":"getting-started/installation/#additional-resources","text":"PX4 ROS2 User Guide Protoc error on build Cosys-AirSim Docs","title":"Additional Resources"},{"location":"tutorials/overview/","text":"","title":"Overview"}]}